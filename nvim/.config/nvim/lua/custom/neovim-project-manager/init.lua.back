-- neovim-project-manager: clean 3-pane rewrite
local M = {}
local api, uv = vim.api, vim.loop

M.config = {
  width = 50,
  height = 20,
  preview_width = 40,
  max_scan_depth = 1,
  root = nil,
  scroll_margin = 4,
}

local state = {
  buf_left = nil,
  buf_mid = nil,
  buf_prv = nil,
  win_left = nil,
  win_mid = nil,
  win_prv = nil,
  items = {},
  parent_items = {},
  filtered = {},
  cursor = 1,
  root = nil,
  query = '',
  fuzzy_win = nil,
  fuzzy_buf = nil,
  namespace = api.nvim_create_namespace 'nvim-project-manager',
}

-- -------------------
-- Utilities
-- -------------------
local function is_dir(path)
  local stat = uv.fs_stat(path)
  return stat and stat.type == 'directory'
end

local function scandir(path)
  local fd = uv.fs_scandir(path)
  if not fd then
    return {}
  end
  local res = {}
  while true do
    local name, typ = uv.fs_scandir_next(fd)
    if not name then
      break
    end
    table.insert(res, { name = name, path = path .. '/' .. name, type = typ or 'file' })
  end
  table.sort(res, function(a, b)
    return a.name < b.name
  end)
  return res
end

local function fuzzy_filter(items, q)
  if not q or q == '' then
    return items
  end
  local out, ql = {}, q:lower()
  for _, it in ipairs(items) do
    if it.name:lower():find(ql, 1, true) then
      table.insert(out, it)
    end
  end
  return out
end

local function safe_set_lines(buf, lines)
  if buf and api.nvim_buf_is_valid(buf) then
    api.nvim_buf_set_option(buf, 'modifiable', true)
    api.nvim_buf_set_lines(buf, 0, -1, false, lines)
    api.nvim_buf_set_option(buf, 'modifiable', false)
  end
end

-- -------------------
-- Rendering
-- -------------------
local function ensure_cursor_visible()
  if not (state.win_mid and api.nvim_win_is_valid(state.win_mid)) then
    return
  end
  local topline = vim.fn.line 'w0'
  local botline = vim.fn.line 'w$'
  local cur = state.cursor
  local margin = M.config.scroll_margin
  if cur < topline + margin then
    api.nvim_win_set_cursor(state.win_mid, { math.max(cur - margin, 1), 0 })
  elseif cur > botline - margin then
    api.nvim_win_set_cursor(state.win_mid, { cur - (botline - topline) + margin, 0 })
  end
end

local function render_left()
  if not (state.buf_left and api.nvim_buf_is_valid(state.buf_left)) then
    return
  end
  local lines = { '[Parent]' }
  for _, it in ipairs(state.parent_items) do
    local icon = (it.type == 'directory') and '' or ''
    table.insert(lines, icon .. ' ' .. it.name)
  end
  safe_set_lines(state.buf_left, lines)
end

local function render_middle()
  if not (state.buf_mid and api.nvim_buf_is_valid(state.buf_mid)) then
    return
  end
  local lines = {}
  for i, it in ipairs(state.filtered) do
    local prefix = (i == state.cursor) and '▶ ' or '  '
    local icon = (it.type == 'directory') and ' ' or ' '
    table.insert(lines, prefix .. icon .. it.name)
  end
  safe_set_lines(state.buf_mid, lines)
  api.nvim_buf_clear_namespace(state.buf_mid, state.namespace, 0, -1)
  if state.cursor >= 1 and state.cursor <= #state.filtered then
    api.nvim_buf_add_highlight(state.buf_mid, state.namespace, 'Visual', state.cursor - 1, 0, -1)
  end
  ensure_cursor_visible()
end

local function render_preview()
  if not (state.buf_prv and api.nvim_buf_is_valid(state.buf_prv)) then
    return
  end
  local item = state.filtered[state.cursor]
  if not item then
    safe_set_lines(state.buf_prv, {})
    return
  end
  if is_dir(item.path) then
    local lines = { '[Directory] ' .. item.path, '' }
    for _, it in ipairs(scandir(item.path)) do
      table.insert(lines, it.name .. '\t' .. it.type)
    end
    safe_set_lines(state.buf_prv, lines)
  else
    local f = io.open(item.path, 'r')
    local lines = {}
    if f then
      for i = 1, 1000 do
        local l = f:read '*l'
        if not l then
          break
        end
        table.insert(lines, l)
      end
      f:close()
    end
    if #lines == 0 then
      lines = { '[Empty]' }
    end
    safe_set_lines(state.buf_prv, lines)
  end
end

local function refresh()
  state.items = scandir(state.root)
  state.parent_items = scandir(state.root:match '(.*/)[^/]+/?$' or state.root)
  state.filtered = fuzzy_filter(state.items, state.query)
  if #state.filtered == 0 then
    state.cursor = 0
  else
    state.cursor = math.max(1, math.min(state.cursor, #state.filtered))
  end
  render_left()
  render_middle()
  render_preview()
end

M.refresh = refresh -- export for fuzzy callback

-- -------------------
-- Actions
-- -------------------
local function open_item()
  local item = state.filtered[state.cursor]
  if not item then
    return
  end
  if is_dir(item.path) then
    state.root = item.path
    state.cursor = 1
    refresh()
  else
    M.close()
    vim.cmd('edit ' .. vim.fn.fnameescape(item.path))
  end
end

local function go_up()
  local up = state.root:match '(.*/)[^/]+/?$'
  if up then
    state.root = up
    state.cursor = 1
    refresh()
  end
end

local function delete_item()
  local item = state.filtered[state.cursor]
  if not item then
    return
  end
  local ok = vim.fn.confirm('Delete ' .. item.path .. '?', '&Yes&No', 2)
  if ok ~= 1 then
    return
  end
  if is_dir(item.path) then
    os.execute('rm -rf ' .. vim.fn.shellescape(item.path))
  else
    os.remove(item.path)
  end
  refresh()
end

local function rename_item()
  local item = state.filtered[state.cursor]
  if not item then
    return
  end
  local newname = vim.fn.input('New name: ', item.name)
  if newname and newname ~= '' then
    uv.fs_rename(item.path, state.root .. '/' .. newname)
    refresh()
  end
end

local function create_file()
  local name = vim.fn.input 'New file: '
  if name and name ~= '' then
    local f = io.open(state.root .. '/' .. name, 'w')
    if f then
      f:close()
    end
    refresh()
  end
end

local function create_dir()
  local name = vim.fn.input 'New dir: '
  if name and name ~= '' then
    uv.fs_mkdir(state.root .. '/' .. name, 493)
    refresh()
  end
end

-- -------------------
-- Fuzzy search
-- -------------------
local function open_fuzzy_window()
  if not (state.win_mid and api.nvim_win_is_valid(state.win_mid)) then
    return
  end
  local width, row = M.config.width, 2
  local buf = api.nvim_create_buf(false, true)
  local win = api.nvim_open_win(buf, true, {
    relative = 'editor',
    row = row,
    col = math.floor((vim.o.columns - width) / 2),
    width = width,
    height = 1,
    style = 'minimal',
    border = 'rounded',
  })
  api.nvim_buf_set_option(buf, 'buftype', 'prompt')
  vim.fn.prompt_setprompt(buf, 'Filter: ')
  api.nvim_buf_set_option(buf, 'modifiable', true)
  state.fuzzy_buf = buf
  state.fuzzy_win = win

  api.nvim_create_autocmd({ 'TextChangedI', 'TextChanged' }, {
    buffer = buf,
    callback = function()
      if not api.nvim_buf_is_valid(buf) then
        return
      end
      local lines = api.nvim_buf_get_lines(buf, 0, -1, false)
      state.query = lines[1] or ''
      state.cursor = 1
      M.refresh()
    end,
  })

  vim.keymap.set('i', '<Esc>', function()
    if api.nvim_win_is_valid(win) then
      api.nvim_win_close(win, true)
    end
    state.fuzzy_win, state.fuzzy_buf = nil, nil
    vim.cmd 'stopinsert'
  end, { buffer = buf, noremap = true, silent = true })
end

-- -------------------
-- Key handler
-- -------------------
local function on_key(key)
  if key == 'j' then
    state.cursor = math.min(state.cursor + 1, #state.filtered)
    render_middle()
    render_preview()
  elseif key == 'k' then
    state.cursor = math.max(state.cursor - 1, 1)
    render_middle()
    render_preview()
  elseif key == 'l' or key == '<CR>' or key == 'o' then
    open_item()
  elseif key == 'h' then
    go_up()
  elseif key == 'd' then
    delete_item()
  elseif key == 'r' then
    rename_item()
  elseif key == 'n' then
    create_file()
  elseif key == 'N' then
    create_dir()
  elseif key == 'f' then
    open_fuzzy_window()
  elseif key == 'q' then
    M.close()
  end
end

-- -------------------
-- Open plugin
-- -------------------
function M.open(opts)
  opts = opts or {}
  for k, v in pairs(opts) do
    M.config[k] = v
  end
  state.root = opts.root or M.config.root or vim.loop.cwd()
  state.cursor = 1
  state.query = ''

  local ui = api.nvim_list_uis()[1]
  local height = math.min(M.config.height, ui.height - 4)
  local mid_width = M.config.width
  local prv_width = M.config.preview_width
  local col_mid = math.floor((ui.width - mid_width - prv_width) / 2)
  local row = math.floor((ui.height - height) / 2)

  state.buf_left = api.nvim_create_buf(false, true)
  state.win_left = api.nvim_open_win(state.buf_left, true, {
    relative = 'editor',
    row = row,
    col = col_mid - 15,
    width = 15,
    height = height,
    style = 'minimal',
    border = 'rounded',
  })
  state.buf_mid = api.nvim_create_buf(false, true)
  state.win_mid = api.nvim_open_win(state.buf_mid, true, {
    relative = 'editor',
    row = row,
    col = col_mid,
    width = mid_width,
    height = height,
    style = 'minimal',
    border = 'rounded',
  })
  state.buf_prv = api.nvim_create_buf(false, true)
  state.win_prv = api.nvim_open_win(state.buf_prv, false, {
    relative = 'editor',
    row = row,
    col = col_mid + mid_width,
    width = prv_width,
    height = height,
    style = 'minimal',
    border = 'rounded',
  })

  local function map(buf, key, fn)
    vim.keymap.set('n', key, fn, { buffer = buf, noremap = true, silent = true, nowait = true })
  end
  local keys = { 'j', 'k', 'l', '<CR>', 'o', 'h', 'd', 'r', 'n', 'N', 'f', 'q' }
  for _, k in ipairs(keys) do
    map(state.buf_mid, k, function()
      on_key(k)
    end)
  end

  refresh()
end

-- -------------------
-- Close
-- -------------------
function M.close()
  local function safe_close(win, buf)
    if win and api.nvim_win_is_valid(win) then
      pcall(api.nvim_win_close, win, true)
    end
    if buf and api.nvim_buf_is_valid(buf) then
      pcall(api.nvim_buf_delete, buf, { force = true })
    end
  end
  safe_close(state.win_left, state.buf_left)
  safe_close(state.win_mid, state.buf_mid)
  safe_close(state.win_prv, state.buf_prv)
  if state.fuzzy_win then
    safe_close(state.fuzzy_win, state.fuzzy_buf)
  end
  state.win_left, state.win_mid, state.win_prv, state.fuzzy_win = nil, nil, nil, nil
  state.buf_left, state.buf_mid, state.buf_prv, state.fuzzy_buf = nil, nil, nil, nil
end

return M
